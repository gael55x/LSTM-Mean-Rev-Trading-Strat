import datetime
import yfinance as yf
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from app.config import FEATURES, TICKER, DATA_DAYS

def download_data(ticker=TICKER):
    # we set an end date as 'today'
    end_date = datetime.datetime.now()
    # we define a start date some days in the past (DATA_DAYS)
    start_date = end_date - datetime.timedelta(days=DATA_DAYS)
    # we download daily price data from yahoo finance
    data = yf.download(
        tickers=ticker,
        start=start_date.strftime('%Y-%m-%d'),
        end=end_date.strftime('%Y-%m-%d'),
        interval='1d',
        progress=False
    )
    # we drop any rows with missing values
    data.dropna(inplace=True)
    
    # if data columns are in multi-index format, flatten them
    if isinstance(data.columns, pd.MultiIndex):
        data.columns = data.columns.get_level_values(0)
    
    # if there's no 'Close' column but there is 'Adj Close', rename it to 'Close'
    if 'Close' not in data.columns and 'Adj Close' in data.columns:
        data['Close'] = data['Adj Close']
    
    # if the data is empty or 'Close' is missing, raise an error
    if data.empty or 'Close' not in data.columns:
        raise ValueError("no data downloaded or the 'close' column is missing.")
    return data

def preprocess_data(data: pd.DataFrame) -> pd.DataFrame:
    # we ensure the 'Close' column exists before we proceed
    if 'Close' in data.columns:
        # we compute moving averages (ma20 and ma50) for technical indicators
        data['MA20'] = data['Close'].rolling(window=20).mean()
        data['MA50'] = data['Close'].rolling(window=50).mean()
    
        # we compute standard deviation (std) and use it to form upper/lower bollinger bands
        data['STD'] = data['Close'].rolling(window=20).std()
        data['Upper_Band'] = data['MA20'] + (data['STD'] * 2.5)
        data['Lower_Band'] = data['MA20'] - (data['STD'] * 2.5)
    
        # we compute %b (pctb) which measures where price sits within bollinger bands
        close = data['Close']
        lower = data['Lower_Band']
        upper = data['Upper_Band']
        data['pctB'] = (close - lower) / (upper - lower)
    
        # we compute rsi using average gains and losses over a 14-day window
        delta = data['Close'].diff()
        up = delta.clip(lower=0)
        down = -1 * delta.clip(upper=0)
        roll_up = up.rolling(14).mean()
        roll_down = down.rolling(14).mean()
        RS = roll_up / roll_down
        data['RSI'] = 100.0 - (100.0 / (1.0 + RS))
    
        # we compute macd as the difference of two ewmas, plus the signal line
        exp1 = data['Close'].ewm(span=12, adjust=False).mean()
        exp2 = data['Close'].ewm(span=26, adjust=False).mean()
        data['MACD'] = exp1 - exp2
        data['Signal_Line'] = data['MACD'].ewm(span=9, adjust=False).mean()
    
        # we compute momentum as close price minus the close price shifted 10 days
        data['Momentum'] = data['Close'] - data['Close'].shift(10)
    
        # we compute the true range (tr) and average true range (atr)
        data['TR'] = data[['High', 'Close']].max(axis=1) - data[['Low', 'Close']].min(axis=1)
        data['ATR'] = data['TR'].rolling(window=14).mean()
    
        # we drop rows with any remaining na values generated by rolling calculations
        data.dropna(inplace=True)
    else:
        raise ValueError("the 'close' column is missing from the data.")
    return data

def scale_data(data: pd.DataFrame):
    # we use a standard scaler to normalize the selected features
    scaler = StandardScaler()
    scaled_data = scaler.fit_transform(data[FEATURES])
    return scaled_data, scaler

def create_sequences(data_array: np.ndarray, seq_length: int):
    # we create sequences of length seq_length for the lstm
    X, y = [], []
    for i in range(seq_length, len(data_array)):
        # we take a window of seq_length data points as one sequence
        X.append(data_array[i - seq_length:i])
        # the label is the 'close' feature in position 0 of the current row
        y.append(data_array[i, 0])
    # we return the sequences and their corresponding labels as arrays
    return np.array(X), np.array(y)
